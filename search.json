[
  {
    "objectID": "editors.html",
    "href": "editors.html",
    "title": "Editors",
    "section": "",
    "text": "This page includes:\nWarning in editor_vacation_status(airtable_base_id): Not all airtable editor\nnames match slack names. GitHub handles of mis-matches: ldecicco-usgs"
  },
  {
    "objectID": "editors.html#editor-in-charge",
    "href": "editors.html#editor-in-charge",
    "title": "Editors",
    "section": "Editor-in-Charge",
    "text": "Editor-in-Charge\nCurrent Editor-in-Charge is Emily Riederer.\nNext Editor-in-Charge (from 2025-02-01) will be Mauro Lepore."
  },
  {
    "objectID": "editors.html#editor-overview",
    "href": "editors.html#editor-overview",
    "title": "Editors",
    "section": "Editor Overview",
    "text": "Editor Overview\nThe following interactive table summarises the availability of our editorial team. This information is intended to help identify editors who may be available to handle new submissions to rOpenSci’s software peer-review system. The choice of editors should also be made in a way that best distributes the recent editorial loads depicted in the Past Editorial Load section.\nValues are sorted by the periods of time since editors were last active in peer review threads (the “Last Active” column), sorted in decreasing order so the first listed editors are those who have been inactive for the longest time. Values in this ‘Last Active’ column are also hyperlinked to the most recent submission issue for each editor. The table can be filtered with the two check-box selectors:\n\nStats to filter by statistical software submission (true), general submission (false), or both.\nEditor Status to filter by the current status of editors. Editors are “FREE” is they are not currently handling any submissions, and are highlighted in yellow.\n\n\n// This adds a 'rowColor' variable to the editor data\neditorData = {\n    return transpose(ed_status_in).map(row =&gt; ({\n        ...row,\n        rowColor: row.status === \"FREE\" ? \"yellow\" : \"transparent\",\n    }));\n}\n\n\n\n\n\n\n\nviewof stats = Inputs.checkbox(\n    [true, false],\n    { value: [false], \n        label: \"Stats:\"\n    }\n)\nviewof status = Inputs.checkbox(\n    [\"FREE\", \"BUSY\", \"ON LEAVE\"], \n    { value: [\"FREE\"], \n        label: \"Editor Status:\"\n    }\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltered = editorData.filter(function(editor) {\n  return status.includes(editor.status) &&\n         stats.includes(editor.stats);\n})\n\nsortColumn = \"inactive_days\"\n\n// This sorts in reverse order:\nfilteredSorted = filtered.sort((a, b) =&gt; {\n  if (a[sortColumn] &lt; b[sortColumn]) {\n    return 1;\n  }\n  if (a[sortColumn] &gt; b[sortColumn]) {\n    return -1;\n  }\n  return 0;\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Definition of colorTable function, adapted from\n// https://observablehq.com/@mootari/colored-table-rows\n// This can't be placed in a separate file, because that requires importing\n// observable/table, but there is no path here to do that import.\nfunction colorTable(data, {\n        colorColumn,\n        colorOpacity = 0.5,\n        editorColumn,\n        lastActiveColumn,\n        issueNumColumn,\n        columns = undefined,\n        format = {}, ...options}) {\n  const [row] = data;\n  if(!row) return Inputs.table(data, options);\n  \n  let index = Object.keys(row).indexOf(colorColumn);\n  if(index &lt; 0) throw Error(\"colorColumn not found in data\");\n  if(format[colorColumn]) throw Error(\"colorColumn is reserved\");\n  if(columns && columns.indexOf(colorColumn) &lt; 0) columns.push(colorColumn);\n  if(columns) index = columns.indexOf(colorColumn);\n  const nth = `nth-child(${index + 2})`;\n\n  // Observable Table doesn't know about rows, so need to convert the\n  // \"lastActiveColumn\" into an array with the issue number and last active\n  // string so then pass to the `format` call below to construct &lt;a&gt; href\n  // objects:\n  const preprocessedData = data.map(row =&gt; ({\n     ...row,\n     [lastActiveColumn]: [row[issueNumColumn],row[lastActiveColumn]]\n  }));``\n\n  const form = Inputs.table(preprocessedData, {\n    format: {\n      ...format,\n      [colorColumn]: d =&gt; htl.html`&lt;div style=\"--row-color:${d}\"&gt;`,\n      [editorColumn]: d =&gt; htl.html`&lt;a href=\"https://github.com/${d}\"&gt;${d}&lt;/a&gt;`,\n      [lastActiveColumn]: d =&gt; htl.html`&lt;a href=\"https://github.com/ropensci/software-review/issues/${d[0]}\"&gt;${d[1]}&lt;/a&gt;`,\n    },\n    columns,\n    ...options\n  });\n\n  const scope = DOM.uid().id;\n  form.classList.add(scope);\n  \n  form.append(htl.html`&lt;style&gt;\n\n    /* Ensure that the sticky header always stays on top */\n    .${scope} thead { position: relative; z-index: 2 }\n\n    /* Hide the last column */\n    .${scope} th:${nth},\n    .${scope} td:${nth} { width: 0; padding: 0 }\n    .${scope} th:${nth} { visibility: hidden }\n\n    /* Inject the background color */\n    .${scope} tr { position: relative }\n    .${scope} td:${nth} div:after {\n      opacity: ${colorOpacity};\n      content: \"\";\n      display: block;\n      height: 100%;\n      width: 100%;\n      position: absolute;\n      left: 0;\n      top: 0;\n      z-index: -1;\n      background-color: var(--row-color);\n    }\n  `);\n\n  return form;\n}\n\n\n\n\n\n\n\n// And modified verison for open reviews table\nfunction reviewTable(data, {\n        colorColumn,\n        colorOpacity = 0.5,\n        issueNumColumn,\n        titleColumn,\n        columns = undefined,\n        format = {}, ...options}) {\n  const [row] = data;\n  if(!row) return Inputs.table(data, options);\n  \n  let index = Object.keys(row).indexOf(colorColumn);\n  if(index &lt; 0) throw Error(\"colorColumn not found in data\");\n  if(format[colorColumn]) throw Error(\"colorColumn is reserved\");\n  if(columns && columns.indexOf(colorColumn) &lt; 0) columns.push(colorColumn);\n  if(columns) index = columns.indexOf(colorColumn);\n  const nth = `nth-child(${index + 2})`;\n\n  // Observable Table doesn't know about rows, so need to convert the\n  // \"titleColumn\" into an array with the title and issue number\n  // so then pass to the `format` call below to construct &lt;a&gt; href\n  // objects:\n  const preprocessedData = data.map(row =&gt; ({\n     ...row,\n     [titleColumn]: [row[titleColumn],row[issueNumColumn]]\n  }));``\n\n  const form = Inputs.table(preprocessedData, {\n    format: {\n      ...format,\n      [colorColumn]: d =&gt; htl.html`&lt;div style=\"--row-color:${d}\"&gt;`,\n      [issueNumColumn]: d =&gt; htl.html`&lt;a href=\"https://github.com/ropensci/software-review/issues/${d}\"&gt;${d}&lt;/a&gt;`,\n      [titleColumn]: d =&gt; htl.html`&lt;span style=\"white-space:break-spaces;\"&gt;&lt;a href=\"https://github.com/ropensci/software-review/issues/${d[1]}\"&gt;${d[0]}&lt;/a&gt;&lt;/span&gt;`,\n    },\n    columns,\n    ...options\n  });\n\n  const scope = DOM.uid().id;\n  form.classList.add(scope);\n  \n  form.append(htl.html`&lt;style&gt;\n\n    /* Ensure that the sticky header always stays on top */\n    .${scope} thead { position: relative; z-index: 2 }\n\n    /* Hide the last column */\n    .${scope} th:${nth},\n    .${scope} td:${nth} { width: 0; padding: 0 }\n    .${scope} th:${nth} { visibility: hidden }\n\n    /* Inject the background color */\n    .${scope} tr { position: relative }\n    .${scope} td:${nth} div:after {\n      opacity: ${colorOpacity};\n      content: \"\";\n      display: block;\n      height: 100%;\n      width: 100%;\n      position: absolute;\n      left: 0;\n      top: 0;\n      z-index: -1;\n      background-color: var(--row-color);\n    }\n  `);\n\n  return form;\n}\n\n\n\n\n\n\n\ncolumns = [\"editor\", \"last_active\", \"status\", \"stats\", \"Languages\", \"Expertise\"]\ncolorTable(filteredSorted,\n  {\n    colorColumn: \"rowColor\",\n    editorColumn: \"editor\",\n    lastActiveColumn: \"last_active\",\n    issueNumColumn: \"number\",\n    columns: columns,\n    height: 'auto',\n    header: {\n      \"editor\": \"Editor\",\n      \"last_active\": \"Last Active\",\n      \"status\": \"Status\",\n      \"stats\": \"Stats\",\n    },\n    format: {\n      \"Expertise\": d =&gt; htl.html`&lt;span style=\"white-space:break-spaces;\"&gt;${d}&lt;/span&gt;`,\n    },\n  }\n)"
  },
  {
    "objectID": "editors.html#editor-reviews",
    "href": "editors.html#editor-reviews",
    "title": "Editors",
    "section": "Editor Reviews",
    "text": "Editor Reviews\nThis panel provides data on reviews handled by each editor. Data are shown for current editors only, with reviews listed from most to least recent. Open reviews are highlighted in yellow.\n\nedReviewsIn = transpose(ed_reviews_in)\n// Get array of unique eds for input selector:\neditorsAll = edReviewsIn.map(function(item) {\n    return item.editor;\n});\neditors = Array.from(new Set(editorsAll));\n\n// Add 'rowColor' variable:\nedReviews = {\n    return edReviewsIn.map(row =&gt; ({\n        ...row,\n        rowColor: row.state === \"OPEN\" ? \"yellow\" : \"transparent\",\n    }));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof editor = Inputs.select(editors, {multiple: false, label: \"Editor:\"})\nviewof state = Inputs.checkbox(\n    [\"OPEN\", \"CLOSED\"],\n    { value: [\"OPEN\"], label: \"Issue State:\" }\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfilteredRevs = edReviews.filter(function(ed) {\n  return editor.includes(ed.editor) && state.includes(ed.state)\n})\n\n\n\n\n\n\n\nsortColumnRevs = \"number\"\n\n// This sorts in reverse order:\nfilteredSortedRevs = filteredRevs.sort((a, b) =&gt; {\n  if (a[sortColumnRevs] &lt; b[sortColumnRevs]) {\n    return 1;\n  }\n  if (a[sortColumnRevs] &gt; b[sortColumnRevs]) {\n    return -1;\n  }\n  return 0;\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnumberColumn = \"number\"\ncolumnsRevs = [\"number\", \"title\", \"state\", \"opened_at\", \"closed_at\"]\n\ncolorTable(filteredSortedRevs,\n  {\n    colorColumn: \"rowColor\",\n    editorColumn: \"editor\",\n    issueNumColumn: \"number\",\n    columns: columnsRevs,\n    format: {\n      [numberColumn]: d =&gt; htl.html`&lt;a href=\"https://github.com/ropensci/software-review/issues/${d}\"&gt;${d}&lt;/a&gt;`,\n      \"title\": d =&gt; htl.html`&lt;span style=\"white-space:break-spaces;\"&gt;${d}&lt;/span&gt;`,\n    },\n    header: {\n      \"number\": \"Issue number\",\n      \"title\": \"Title\",\n      \"state\": \"State\",\n      \"opened_at\": \"Opened\",\n      \"closed_at\": \"Closed\",\n    },\n    height: 'auto',\n  }\n)"
  },
  {
    "objectID": "editors.html#past-ed-load",
    "href": "editors.html#past-ed-load",
    "title": "Editors",
    "section": "Editorial Load",
    "text": "Editorial Load\nThe following sections summarise the recent workload of our editorial team. We aim to distribute our workload as evenly as possible across the editorial team. Editors for new submissions should accordingly be chosen from those who have had relatively low recent workloads. All of the following data and graphs exclude any editors who are currently on leave.\n\nIndividual Editor Load: New Submissions\nThis first graph shows the number of new submissions per quarter taken on by each editor. We aim to allocate no more than one new submission to each editor per quarter, or a maximum of four per year. Each block in this graph represents a quarter-year, so values should not exceed one. Editors for incoming reviews should preferably be chosen from those who have not handled any submissions in the present or preceding quarters.\n\n\n\n\n\n\n\n\n\n\nIndividual Editor Load: Concurrent Reviews\nThe following graph shows numbers of concurrent reviews handled by editors over the preceding 2 years. We aim to distribute workloads across editors as evenly as possible, and this graph should be used in addition to the above graph to aid that task. Note that we have no specific upper limits on numbers of concurrent reviews, and reviews may extend over long time periods with very little editorial intervention. Nevertheless, low numbers of concurrent reviews may be interpreted to reflect relatively low editorial workload."
  },
  {
    "objectID": "history.html",
    "href": "history.html",
    "title": "Historical Data",
    "section": "",
    "text": "This page includes several graphs providing insight into the historical development of rOpenSci’s software peer review process. The first three graphs includes results distinguishing general review from statistical software review starting from September 2021. Prior to this time, all reviews were “general”."
  },
  {
    "objectID": "history.html#package-submissions",
    "href": "history.html#package-submissions",
    "title": "Historical Data",
    "section": "Package submissions",
    "text": "Package submissions\nThis chart shows the total number of packages submitted for review each quarter. A value of 12 per quarter equates to around one submission per week. The controls immediately below, and in all of the following plots, can be used to control the first year of data shown in the plot.\n\nsubmissions = {\n    return transpose(submissions_in).map(row =&gt; ({\n        ...row,\n        date: new Date(row.date),\n        submissionYear: new Date(row.date).getFullYear()\n    }));\n}\n\n\n\n\n\n\n\nminYear = Math.min(...submissions.map(d =&gt; d.submissionYear));\nmaxYear = Math.max(...submissions.map(d =&gt; d.submissionYear));\nviewof submissionYear = Inputs.range(\n    [minYear, maxYear],\n    {\n        step: 1,\n        label: \"Start year\",\n        value: minYear // default = (min + max) / 2\n    }\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsubmissionsFiltered = {\n    return submissions.filter(d =&gt; d.submissionYear &gt;= submissionYear);\n}\n\n\n\n\n\n\n\nPlot.plot({\n    style: `\n        overflow: visible;\n    `,\n    marginLeft: 60,\n    marginBottom: 50,\n    x: {grid: true},\n    y: {grid: true},\n    marks: [\n        Plot.ruleY([0]),\n        Plot.lineY(\n            submissionsFiltered,\n            {\n                x: \"date\",\n                y: \"submissions\",\n                stroke: \"type\",\n                fontSize: 18\n            }\n        ),\n        Plot.text(\n            submissionsFiltered,\n            Plot.selectLast({\n                x: \"date\",\n                y: \"submissions\",\n                z: \"type\",\n                text: \"type\",\n                textAnchor: \"start\",\n                dx: 3,\n                fontSize: 18\n            })\n        ),\n        Plot.axisX(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisX(\n            {\n                fontSize: 20,\n                label: \"Year\",\n                labelAnchor: \"center\",\n                labelOffset: 40,\n                ticks: []\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 24,\n                label: \"Nr. submissions / quarter\",\n                labelAnchor: \"center\",\n                labelOffset: 55,\n                ticks: []\n            }\n        ),\n    ]\n})"
  },
  {
    "objectID": "history.html#packages-under-review",
    "href": "history.html#packages-under-review",
    "title": "Historical Data",
    "section": "Packages under review",
    "text": "Packages under review\nThis chart shows numbers of packages simultaneously under review each quarter.\n\nreviews = {\n    return transpose(reviews_in).map(row =&gt; ({\n        ...row,\n        date: new Date(row.date),\n        reviewYear: new Date(row.date).getFullYear()\n    }));\n}\n\n\n\n\n\n\n\n// Use 'minYear' and 'maxYear' from above\nviewof reviewYear = Inputs.range(\n    [minYear, maxYear],\n    {\n        step: 1,\n        label: \"Start year\",\n        value: minYear\n    }\n)\n\n\n\n\n\n\n\nreviewsFiltered = {\n    return reviews.filter(d =&gt; d.reviewYear &gt;= reviewYear);\n}\n\n\n\n\n\n\n\nPlot.plot({\n    style: `\n        overflow: visible;\n    `,\n    marginLeft: 60,\n    marginBottom: 50,\n    x: {grid: true},\n    y: {grid: true},\n    marks: [\n        Plot.ruleY(\n            [0]\n        ),\n        Plot.lineY(\n            reviewsFiltered,\n            {\n                x: \"date\",\n                y: \"reviews\",\n                stroke: \"type\",\n                fontSize: 18\n            }\n        ),\n        Plot.text(\n            reviewsFiltered,\n            Plot.selectLast({\n                x: \"date\",\n                y: \"reviews\",\n                z: \"type\",\n                text: \"type\",\n                textAnchor: \"start\",\n                dx: 3,\n                fontSize: 18\n            })\n        ),\n        Plot.axisX(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisX(\n            {\n                fontSize: 20,\n                label: \"Year\",\n                labelAnchor: \"center\",\n                labelOffset: 40,\n                ticks: []\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 24,\n                label: \"Nr. active reviews / quarter\",\n                labelAnchor: \"center\",\n                labelOffset: 55,\n                ticks: []\n            }\n        ),\n    ]\n})"
  },
  {
    "objectID": "history.html#review-duration",
    "href": "history.html#review-duration",
    "title": "Historical Data",
    "section": "Review durations",
    "text": "Review durations\nReview durations are displayed here in terms of two main measures:\n\nOverall Review Durations, which are the durations of the entire review process, from the date packages are first submitted until they are accepted.\nIndividual Review Times, which are the times spent by individual reviewers on their package reviews.\n\nThe first two of the following charts are time series charts plotted against the months in which each review started, with data slightly smoothed to aid visual display. Data for “stats” reviews may not extend to current date, if data for the current quarter are insufficient for statistical analyses. In these cases, data for “general” reviews are also truncated to same length as those for “stats” reviews. Data for “all” reviews should nevertheless always extend to the current date.\nFollowing the two time series charts are two histogram plots, again for the two distinct measures described above.\n\nOverall Review durations\n\nrevDur = {\n    return transpose(revDurIn).map(row =&gt; ({\n        ...row,\n        date: new Date(row.date),\n        revDurYear: new Date(row.date).getFullYear(),\n    }));\n}\n\n\n\n\n\n\n\nviewof revDurYear = Inputs.range(\n    [minYear, maxYear],\n    {\n        step: 1,\n        label: \"Start year\",\n        value: minYear,\n    }\n)\n\n\n\n\n\n\n\nrevDurFiltered = {\n    return revDur.filter(d =&gt; d.revDurYear &gt;= revDurYear);\n}\n\nmaxRev = 1.05 * Math.max(...revDurFiltered.map(d =&gt; d.type === \"all\" && d.dur));\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n    style: `\n        overflow: visible;\n    `,\n    marginLeft: 60,\n    marginBottom: 50,\n    x: {grid: true},\n    y: {grid: true, domain: [0, maxRev]},\n    marks: [\n        Plot.ruleY(\n            [0]\n        ),\n        Plot.lineY(\n            revDurFiltered,\n            {\n                x: \"date\",\n                y: \"dur\",\n                stroke: \"type\",\n                fontSize: 18\n            }\n        ),\n        Plot.text(\n            revDurFiltered,\n            Plot.selectLast({\n                x: \"date\",\n                y: \"dur\",\n                z: \"type\",\n                text: \"type\",\n                textAnchor: \"start\",\n                dx: 4,\n                fontSize: 18\n            })\n        ),\n        Plot.axisX(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisX(\n            {\n                fontSize: 20,\n                label: \"Year\",\n                labelAnchor: \"center\",\n                labelOffset: 40,\n                ticks: []\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 24,\n                label: \"Review duration (months)\",\n                labelAnchor: \"center\",\n                labelOffset: 55,\n                ticks: []\n            }\n        ),\n    ]\n})\n\n\n\n\n\n\n\n\nIndividual Review Times\n\nrevHours = {\n    return transpose(revHoursIn).map(row =&gt; ({\n        ...row,\n        date: new Date(row.date),\n        revHoursYear: new Date(row.date).getFullYear(),\n    }));\n}\nrevHist = {\n    return transpose(revHistIn)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof revHoursYear = Inputs.range(\n    [minYear, maxYear],\n    {\n        step: 1,\n        label: \"Start year\",\n        value: minYear,\n    }\n)\n\n\n\n\n\n\n\nrevHoursFiltered = {\n    return revHours.filter(d =&gt; d.revHoursYear &gt;= revHoursYear);\n}\n\nmaxHours = 1.05 * Math.max(...revHoursFiltered.map(d =&gt; d.type === \"all\" && d.hours));\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n    style: `\n        overflow: visible;\n    `,\n    marginLeft: 60,\n    marginBottom: 50,\n    x: {grid: true},\n    y: {grid: true, domain: [0, maxHours]},\n    marks: [\n        Plot.ruleY(\n            [0]\n        ),\n        Plot.lineY(\n            revHoursFiltered,\n            {\n                x: \"date\",\n                y: \"hours\",\n                stroke: \"type\",\n                fontSize: 18\n            }\n        ),\n        Plot.text(\n            revHoursFiltered,\n            Plot.selectLast({\n                x: \"date\",\n                y: \"hours\",\n                z: \"type\",\n                text: \"type\",\n                textAnchor: \"start\",\n                dx: 4,\n                fontSize: 18\n            })\n        ),\n        Plot.axisX(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisX(\n            {\n                fontSize: 20,\n                label: \"Year\",\n                labelAnchor: \"center\",\n                labelOffset: 40,\n                ticks: []\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 24,\n                label: \"Review time (hours)\",\n                labelAnchor: \"center\",\n                labelOffset: 55,\n                ticks: []\n            }\n        ),\n    ]\n})\n\n\n\n\n\n\n\n\nHistograms of Review Durations and Times\nThe following plots are histograms of overall durations of the entire review process (in days), followed by durations required for individual reviews (in hours). The “Start year” filter removes all data prior to the specified year.\n\nviewof year = Inputs.range(\n    [minYear, maxYear],\n    {\n        step: 1,\n        label: \"Start year\",\n        value: minYear,\n    }\n)\n\n\n\n\n\n\n\nrevHistFiltered = {\n    return revHist.filter(d =&gt; d.year &gt;= year);\n}\n\n\n\n\n\n\n\nPlot.plot({\n    height: 300,\n    marginLeft: 60,\n    marginTop: 50,\n    marginBottom: 50,\n    y: {grid: true},\n    marks: [\n        // Default for all preceding plots is the \"Tabluea10\" colour scheme:\n        // https://www.tableau.com/blog/colors-upgrade-tableau-10-56782\n        Plot.barY(\n            revHistFiltered,\n            Plot.binX(\n                {y: \"count\"}, \n                {x: \"days\", stroke: \"#4e79a7\", strokeWidth: 2})\n        ),\n        Plot.text(\n            [\"Overall review durations in days\"],\n            {\n                frameAnchor: \"top\", \n                fontSize: 24, \n                dy: -30}\n        ),\n        Plot.axisX(\n            {\n                fontSize: 14, \n                label: \"\", \n                labelArrow: false, \n                dy: 5}\n        ),\n        Plot.axisY(\n            {\n                fontSize: 14, \n                label: \"\", \n                labelArrow: false}\n        ),\n        Plot.axisY(\n            {\n                fontSize: 18, \n                label: \"Frequency\", \n                labelAnchor: \"center\", \n                labelOffset: 55, \n                ticks: []\n            }\n        )\n    ]\n})\n\n\n\n\n\n\n\nPlot.plot({\n    height: 300,\n    marginLeft: 60,\n    marginTop: 50,\n    marginBottom: 50,\n    y: {grid: true},\n    marks: [\n        Plot.barY(\n            revHistFiltered,\n            Plot.binX(\n                {y: \"count\"}, \n                {x: \"hours\", stroke: \"#4e79a7\", strokeWidth: 2}\n            )\n        ),\n        Plot.text(\n            [\"Individual review times in hours\"],\n            {\n                frameAnchor: \"top\", \n                fontSize: 24, \n                dy: -30\n            }\n        ),\n        Plot.axisX(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false,\n                dy: 5\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 18,\n                label: \"Frequency\",\n                labelAnchor: \"center\",\n                labelOffset: 55,\n                ticks: []\n            }\n        )\n    ]\n})"
  },
  {
    "objectID": "history.html#numbers-of-editors",
    "href": "history.html#numbers-of-editors",
    "title": "Historical Data",
    "section": "Numbers of Editors",
    "text": "Numbers of Editors\n\n\nWarning in editor_vacation_status(airtable_base_id): Not all airtable editor\nnames match slack names. GitHub handles of mis-matches: ldecicco-usgs\n\n\nrOpenSci relies on our team of volunteer editors. We can only provide review services if we have sufficient numbers of editors available to handle submissions. It is therefore important to monitor historical trends in overall editor availability. This graph shows total numbers of editors over time, and corresponding lines for numbers of those engaged during each time period in ongoing reviews (“Busy”), and numbers who are not handling any submissions during each period and are therefore free to accept new submissions (“Free”).\n\nnumEds = {\n    return transpose(numEdsIn).map(row =&gt; ({\n        ...row,\n        month: new Date(row.month),\n        numEdsYear: new Date(row.month).getFullYear(),\n    }));\n}\n\n\n\n\n\n\n\nviewof numEdsYear = Inputs.range(\n    [minYear, maxYear],\n    {\n        step: 1,\n        label: \"Start year\",\n        value: minYear,\n    }\n)\n\n\n\n\n\n\n\nnumEdsFiltered = {\n    return numEds.filter(d =&gt; d.numEdsYear &gt;= numEdsYear);\n}\n\n\n\n\n\n\n\nPlot.plot({\n    style: `\n        overflow: visible;\n    `,\n    marginLeft: 60,\n    marginBottom: 50,\n    x: {grid: true},\n    y: {grid: true},\n    marks: [\n        Plot.ruleY(\n            [0]),\n        Plot.lineY(\n            numEdsFiltered,\n            {\n                x: \"month\",\n                y: \"n\",\n                stroke: \"status\",\n                fontSize: 18\n            }\n        ),\n        Plot.text(\n            numEdsFiltered,\n            Plot.selectLast({\n                x: \"month\",\n                y: \"n\",\n                z: \"status\",\n                text: \"status\",\n                textAnchor: \"start\",\n                dx: 4,\n                fontSize: 18\n            })\n        ),\n        Plot.axisX(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisX(\n            {\n                fontSize: 20,\n                label: \"Year\",\n                labelAnchor: \"center\",\n                labelOffset: 40,\n                ticks: []\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 14,\n                label: \"\",\n                labelArrow: false\n            }\n        ),\n        Plot.axisY(\n            {\n                fontSize: 24,\n                label: \"Number of editors\",\n                labelAnchor: \"center\",\n                labelOffset: 55,\n                ticks: []\n            }\n        ),\n    ]\n})"
  },
  {
    "objectID": "reviews.html",
    "href": "reviews.html",
    "title": "Software Review",
    "section": "",
    "text": "rOpenSci software peer-review is currently handling:\n\n2 pre-submission issues\n14 standard issues\n7 stats issues\n\nThe following table provides details of each issue, with results filtered by the following controls:\n\n“Submission Stage” to list issues with the specified stage.\n“Holding” to list issues which are on hold (true) or not (false).\n“Sort By” to sort results either by the Submission Stage (“stage”, 0-5), or “urgency”, as described below.\n\nSome rows in the table are highlighted to visually indicate degrees of urgency according to the scheme defined in the following sub-section. Rows with no highlight may be considered up-to-date, and require no action. Submissions which have not yet been given a ‘Stage’ label are listed below as ‘(No stage)’, and highlighted with the highest urgency level.\n\nurgency_colours = [\"#FFFF8088\", \"#FFFF0088\", \"#FFAA0088\", \"#FF550088\", \"#FF000088\"]\n\nsubmissionsIn = {\n    return transpose(submissions).map(row =&gt; ({\n        ...row,\n        rowColor: row.urgency === 1 ? urgency_colours[0] :\n            row.urgency === 2 ? urgency_colours[1] :\n            row.urgency === 3 ? urgency_colours[2] :\n            row.urgency === 4 ? urgency_colours[3] :\n            row.urgency === 5 ? urgency_colours[4] : \"transparent\",\n    }));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof stage = {\n    const input =  Inputs.checkbox(\n        [\"(No stage)\",\n         \"0/presubmission\",\n         \"1/editor-checks\",\n         \"2/seeking-reviewer(s)\",\n         \"3/reviewer(s)-assigned\",\n         \"4/review(s)-in-awaiting-changes\",\n         \"5/awaiting-reviewer(s)-response\"\n        ],\n        {\n            value: [\n                \"(No stage)\",\n                \"0/presubmission\",\n                \"1/editor-checks\",\n                \"2/seeking-reviewer(s)\",\n                \"3/reviewer(s)-assigned\",\n                \"4/review(s)-in-awaiting-changes\",\n                \"5/awaiting-reviewer(s)-response\"\n            ],\n            label: htl.html`&lt;b&gt;Submission Stage:&lt;/b&gt;`,\n        }\n    );\n\n    // Modification ideas from\n    // https://talk.observablehq.com/t/what-is-the-best-way-to-style-an-input-checkbox/7690/2\n    const scope = DOM.uid().id;\n    input.classList.add(scope);\n\n    input.append(htl.html`&lt;style&gt;\n    .${scope} &gt; div, .${scope} &gt; div label { display: flex; flex-wrap: wrap; gap: 10px; width: 300px }\n    `)\n\n    return input;\n}\n\n\n\n\n\n\n\n\n\n\nviewof holding = Inputs.checkbox(\n    [true, false],\n    {\n        value: [false],\n        label: htl.html`&lt;b&gt;Holding:&lt;/b&gt;`,\n    }\n)\n\n\n\n\n\n\n\n\n\n\nviewof sortBy = Inputs.radio(\n    [\"stage\", \"urgency\"],\n    {\n        value: \"stage\",\n        label: htl.html`&lt;b&gt;Sort by:&lt;/b&gt;`,\n    }\n)\n\n\n\n\n\n\n\n\n\n\nfiltered = submissionsIn.filter(function(submission) {\n  return stage.includes(submission.stage) &&\n    holding.includes(submission.holding)\n})\n// Only sort by urgency if there are any:\nanyUrgent = filtered.some(submission =&gt; submission.urgency &gt; 0)\nsortCol1 = sortBy === \"stage\" ? \"stage\" : anyUrgent ? \"urgency_rev\" : \"stage\"\nsortCol2 = \"elapsed_days\"\n\n// Sorts by both stage and elapsed days:\nfilteredSorted = filtered.sort((a, b) =&gt; {\n    if (a[sortCol1] &gt; b[sortCol1]) {\n        return 1;\n    } else if (a[sortCol1] &lt; b[sortCol1]) {\n        return -1;\n    } else {\n        if (a[sortCol2] &lt; b[sortCol2]) {\n            return 1;\n        } else if (a[sortCol2] &gt; b[sortCol2]) {\n            return -1;\n        }\n    }\n    return 0;\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Definition of colorTable function, adapted from\n// https://observablehq.com/@mootari/colored-table-rows\n// This can't be placed in a separate file, because that requires importing\n// observable/table, but there is no path here to do that import.\nfunction colorTable(data, {\n        colorColumn,\n        colorOpacity = 0.5,\n        editorColumn,\n        lastActiveColumn,\n        issueNumColumn,\n        columns = undefined,\n        format = {}, ...options}) {\n  const [row] = data;\n  if(!row) return Inputs.table(data, options);\n  \n  let index = Object.keys(row).indexOf(colorColumn);\n  if(index &lt; 0) throw Error(\"colorColumn not found in data\");\n  if(format[colorColumn]) throw Error(\"colorColumn is reserved\");\n  if(columns && columns.indexOf(colorColumn) &lt; 0) columns.push(colorColumn);\n  if(columns) index = columns.indexOf(colorColumn);\n  const nth = `nth-child(${index + 2})`;\n\n  // Observable Table doesn't know about rows, so need to convert the\n  // \"lastActiveColumn\" into an array with the issue number and last active\n  // string so then pass to the `format` call below to construct &lt;a&gt; href\n  // objects:\n  const preprocessedData = data.map(row =&gt; ({\n     ...row,\n     [lastActiveColumn]: [row[issueNumColumn],row[lastActiveColumn]]\n  }));``\n\n  const form = Inputs.table(preprocessedData, {\n    format: {\n      ...format,\n      [colorColumn]: d =&gt; htl.html`&lt;div style=\"--row-color:${d}\"&gt;`,\n      [editorColumn]: d =&gt; htl.html`&lt;a href=\"https://github.com/${d}\"&gt;${d}&lt;/a&gt;`,\n      [lastActiveColumn]: d =&gt; htl.html`&lt;a href=\"https://github.com/ropensci/software-review/issues/${d[0]}\"&gt;${d[1]}&lt;/a&gt;`,\n    },\n    columns,\n    ...options\n  });\n\n  const scope = DOM.uid().id;\n  form.classList.add(scope);\n  \n  form.append(htl.html`&lt;style&gt;\n\n    /* Ensure that the sticky header always stays on top */\n    .${scope} thead { position: relative; z-index: 2 }\n\n    /* Hide the last column */\n    .${scope} th:${nth},\n    .${scope} td:${nth} { width: 0; padding: 0 }\n    .${scope} th:${nth} { visibility: hidden }\n\n    /* Inject the background color */\n    .${scope} tr { position: relative }\n    .${scope} td:${nth} div:after {\n      opacity: ${colorOpacity};\n      content: \"\";\n      display: block;\n      height: 100%;\n      width: 100%;\n      position: absolute;\n      left: 0;\n      top: 0;\n      z-index: -1;\n      background-color: var(--row-color);\n    }\n  `);\n\n  return form;\n}\n\n\n\n\n\n\n\n// And modified verison for open reviews table\nfunction reviewTable(data, {\n        colorColumn,\n        colorOpacity = 0.5,\n        issueNumColumn,\n        titleColumn,\n        columns = undefined,\n        format = {}, ...options}) {\n  const [row] = data;\n  if(!row) return Inputs.table(data, options);\n  \n  let index = Object.keys(row).indexOf(colorColumn);\n  if(index &lt; 0) throw Error(\"colorColumn not found in data\");\n  if(format[colorColumn]) throw Error(\"colorColumn is reserved\");\n  if(columns && columns.indexOf(colorColumn) &lt; 0) columns.push(colorColumn);\n  if(columns) index = columns.indexOf(colorColumn);\n  const nth = `nth-child(${index + 2})`;\n\n  // Observable Table doesn't know about rows, so need to convert the\n  // \"titleColumn\" into an array with the title and issue number\n  // so then pass to the `format` call below to construct &lt;a&gt; href\n  // objects:\n  const preprocessedData = data.map(row =&gt; ({\n     ...row,\n     [titleColumn]: [row[titleColumn],row[issueNumColumn]]\n  }));``\n\n  const form = Inputs.table(preprocessedData, {\n    format: {\n      ...format,\n      [colorColumn]: d =&gt; htl.html`&lt;div style=\"--row-color:${d}\"&gt;`,\n      [issueNumColumn]: d =&gt; htl.html`&lt;a href=\"https://github.com/ropensci/software-review/issues/${d}\"&gt;${d}&lt;/a&gt;`,\n      [titleColumn]: d =&gt; htl.html`&lt;span style=\"white-space:break-spaces;\"&gt;&lt;a href=\"https://github.com/ropensci/software-review/issues/${d[1]}\"&gt;${d[0]}&lt;/a&gt;&lt;/span&gt;`,\n    },\n    columns,\n    ...options\n  });\n\n  const scope = DOM.uid().id;\n  form.classList.add(scope);\n  \n  form.append(htl.html`&lt;style&gt;\n\n    /* Ensure that the sticky header always stays on top */\n    .${scope} thead { position: relative; z-index: 2 }\n\n    /* Hide the last column */\n    .${scope} th:${nth},\n    .${scope} td:${nth} { width: 0; padding: 0 }\n    .${scope} th:${nth} { visibility: hidden }\n\n    /* Inject the background color */\n    .${scope} tr { position: relative }\n    .${scope} td:${nth} div:after {\n      opacity: ${colorOpacity};\n      content: \"\";\n      display: block;\n      height: 100%;\n      width: 100%;\n      position: absolute;\n      left: 0;\n      top: 0;\n      z-index: -1;\n      background-color: var(--row-color);\n    }\n  `);\n\n  return form;\n}\n\n\n\n\n\n\n\ncolumns = [\"stage_num\", \"number\", \"title\", \"stats\", \"stage_date\", \"editor\", \"inactive_for\"]\nreviewTable(filteredSorted,\n  {\n    colorColumn: \"rowColor\",\n    issueNumColumn: \"number\",\n    titleColumn: \"title\",\n    columns: columns,\n    height: 'auto',\n    layout: 'auto',\n    header: {\n        stage_num: \"Stage\",\n        number: \"Number\",\n        title: \"Title\",\n        stats: \"Stats?\",\n        stage_date: \"Stage date\",\n        inactive_for: \"Inactive for\",\n    },\n    format: {\n        stage_num: s =&gt; s === -1 ? \"(No stage)\" : s,\n    }\n  }\n)"
  },
  {
    "objectID": "reviews.html#current-reviews",
    "href": "reviews.html#current-reviews",
    "title": "Software Review",
    "section": "",
    "text": "rOpenSci software peer-review is currently handling:\n\n2 pre-submission issues\n14 standard issues\n7 stats issues\n\nThe following table provides details of each issue, with results filtered by the following controls:\n\n“Submission Stage” to list issues with the specified stage.\n“Holding” to list issues which are on hold (true) or not (false).\n“Sort By” to sort results either by the Submission Stage (“stage”, 0-5), or “urgency”, as described below.\n\nSome rows in the table are highlighted to visually indicate degrees of urgency according to the scheme defined in the following sub-section. Rows with no highlight may be considered up-to-date, and require no action. Submissions which have not yet been given a ‘Stage’ label are listed below as ‘(No stage)’, and highlighted with the highest urgency level.\n\nurgency_colours = [\"#FFFF8088\", \"#FFFF0088\", \"#FFAA0088\", \"#FF550088\", \"#FF000088\"]\n\nsubmissionsIn = {\n    return transpose(submissions).map(row =&gt; ({\n        ...row,\n        rowColor: row.urgency === 1 ? urgency_colours[0] :\n            row.urgency === 2 ? urgency_colours[1] :\n            row.urgency === 3 ? urgency_colours[2] :\n            row.urgency === 4 ? urgency_colours[3] :\n            row.urgency === 5 ? urgency_colours[4] : \"transparent\",\n    }));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewof stage = {\n    const input =  Inputs.checkbox(\n        [\"(No stage)\",\n         \"0/presubmission\",\n         \"1/editor-checks\",\n         \"2/seeking-reviewer(s)\",\n         \"3/reviewer(s)-assigned\",\n         \"4/review(s)-in-awaiting-changes\",\n         \"5/awaiting-reviewer(s)-response\"\n        ],\n        {\n            value: [\n                \"(No stage)\",\n                \"0/presubmission\",\n                \"1/editor-checks\",\n                \"2/seeking-reviewer(s)\",\n                \"3/reviewer(s)-assigned\",\n                \"4/review(s)-in-awaiting-changes\",\n                \"5/awaiting-reviewer(s)-response\"\n            ],\n            label: htl.html`&lt;b&gt;Submission Stage:&lt;/b&gt;`,\n        }\n    );\n\n    // Modification ideas from\n    // https://talk.observablehq.com/t/what-is-the-best-way-to-style-an-input-checkbox/7690/2\n    const scope = DOM.uid().id;\n    input.classList.add(scope);\n\n    input.append(htl.html`&lt;style&gt;\n    .${scope} &gt; div, .${scope} &gt; div label { display: flex; flex-wrap: wrap; gap: 10px; width: 300px }\n    `)\n\n    return input;\n}\n\n\n\n\n\n\n\n\n\n\nviewof holding = Inputs.checkbox(\n    [true, false],\n    {\n        value: [false],\n        label: htl.html`&lt;b&gt;Holding:&lt;/b&gt;`,\n    }\n)\n\n\n\n\n\n\n\n\n\n\nviewof sortBy = Inputs.radio(\n    [\"stage\", \"urgency\"],\n    {\n        value: \"stage\",\n        label: htl.html`&lt;b&gt;Sort by:&lt;/b&gt;`,\n    }\n)\n\n\n\n\n\n\n\n\n\n\nfiltered = submissionsIn.filter(function(submission) {\n  return stage.includes(submission.stage) &&\n    holding.includes(submission.holding)\n})\n// Only sort by urgency if there are any:\nanyUrgent = filtered.some(submission =&gt; submission.urgency &gt; 0)\nsortCol1 = sortBy === \"stage\" ? \"stage\" : anyUrgent ? \"urgency_rev\" : \"stage\"\nsortCol2 = \"elapsed_days\"\n\n// Sorts by both stage and elapsed days:\nfilteredSorted = filtered.sort((a, b) =&gt; {\n    if (a[sortCol1] &gt; b[sortCol1]) {\n        return 1;\n    } else if (a[sortCol1] &lt; b[sortCol1]) {\n        return -1;\n    } else {\n        if (a[sortCol2] &lt; b[sortCol2]) {\n            return 1;\n        } else if (a[sortCol2] &gt; b[sortCol2]) {\n            return -1;\n        }\n    }\n    return 0;\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Definition of colorTable function, adapted from\n// https://observablehq.com/@mootari/colored-table-rows\n// This can't be placed in a separate file, because that requires importing\n// observable/table, but there is no path here to do that import.\nfunction colorTable(data, {\n        colorColumn,\n        colorOpacity = 0.5,\n        editorColumn,\n        lastActiveColumn,\n        issueNumColumn,\n        columns = undefined,\n        format = {}, ...options}) {\n  const [row] = data;\n  if(!row) return Inputs.table(data, options);\n  \n  let index = Object.keys(row).indexOf(colorColumn);\n  if(index &lt; 0) throw Error(\"colorColumn not found in data\");\n  if(format[colorColumn]) throw Error(\"colorColumn is reserved\");\n  if(columns && columns.indexOf(colorColumn) &lt; 0) columns.push(colorColumn);\n  if(columns) index = columns.indexOf(colorColumn);\n  const nth = `nth-child(${index + 2})`;\n\n  // Observable Table doesn't know about rows, so need to convert the\n  // \"lastActiveColumn\" into an array with the issue number and last active\n  // string so then pass to the `format` call below to construct &lt;a&gt; href\n  // objects:\n  const preprocessedData = data.map(row =&gt; ({\n     ...row,\n     [lastActiveColumn]: [row[issueNumColumn],row[lastActiveColumn]]\n  }));``\n\n  const form = Inputs.table(preprocessedData, {\n    format: {\n      ...format,\n      [colorColumn]: d =&gt; htl.html`&lt;div style=\"--row-color:${d}\"&gt;`,\n      [editorColumn]: d =&gt; htl.html`&lt;a href=\"https://github.com/${d}\"&gt;${d}&lt;/a&gt;`,\n      [lastActiveColumn]: d =&gt; htl.html`&lt;a href=\"https://github.com/ropensci/software-review/issues/${d[0]}\"&gt;${d[1]}&lt;/a&gt;`,\n    },\n    columns,\n    ...options\n  });\n\n  const scope = DOM.uid().id;\n  form.classList.add(scope);\n  \n  form.append(htl.html`&lt;style&gt;\n\n    /* Ensure that the sticky header always stays on top */\n    .${scope} thead { position: relative; z-index: 2 }\n\n    /* Hide the last column */\n    .${scope} th:${nth},\n    .${scope} td:${nth} { width: 0; padding: 0 }\n    .${scope} th:${nth} { visibility: hidden }\n\n    /* Inject the background color */\n    .${scope} tr { position: relative }\n    .${scope} td:${nth} div:after {\n      opacity: ${colorOpacity};\n      content: \"\";\n      display: block;\n      height: 100%;\n      width: 100%;\n      position: absolute;\n      left: 0;\n      top: 0;\n      z-index: -1;\n      background-color: var(--row-color);\n    }\n  `);\n\n  return form;\n}\n\n\n\n\n\n\n\n// And modified verison for open reviews table\nfunction reviewTable(data, {\n        colorColumn,\n        colorOpacity = 0.5,\n        issueNumColumn,\n        titleColumn,\n        columns = undefined,\n        format = {}, ...options}) {\n  const [row] = data;\n  if(!row) return Inputs.table(data, options);\n  \n  let index = Object.keys(row).indexOf(colorColumn);\n  if(index &lt; 0) throw Error(\"colorColumn not found in data\");\n  if(format[colorColumn]) throw Error(\"colorColumn is reserved\");\n  if(columns && columns.indexOf(colorColumn) &lt; 0) columns.push(colorColumn);\n  if(columns) index = columns.indexOf(colorColumn);\n  const nth = `nth-child(${index + 2})`;\n\n  // Observable Table doesn't know about rows, so need to convert the\n  // \"titleColumn\" into an array with the title and issue number\n  // so then pass to the `format` call below to construct &lt;a&gt; href\n  // objects:\n  const preprocessedData = data.map(row =&gt; ({\n     ...row,\n     [titleColumn]: [row[titleColumn],row[issueNumColumn]]\n  }));``\n\n  const form = Inputs.table(preprocessedData, {\n    format: {\n      ...format,\n      [colorColumn]: d =&gt; htl.html`&lt;div style=\"--row-color:${d}\"&gt;`,\n      [issueNumColumn]: d =&gt; htl.html`&lt;a href=\"https://github.com/ropensci/software-review/issues/${d}\"&gt;${d}&lt;/a&gt;`,\n      [titleColumn]: d =&gt; htl.html`&lt;span style=\"white-space:break-spaces;\"&gt;&lt;a href=\"https://github.com/ropensci/software-review/issues/${d[1]}\"&gt;${d[0]}&lt;/a&gt;&lt;/span&gt;`,\n    },\n    columns,\n    ...options\n  });\n\n  const scope = DOM.uid().id;\n  form.classList.add(scope);\n  \n  form.append(htl.html`&lt;style&gt;\n\n    /* Ensure that the sticky header always stays on top */\n    .${scope} thead { position: relative; z-index: 2 }\n\n    /* Hide the last column */\n    .${scope} th:${nth},\n    .${scope} td:${nth} { width: 0; padding: 0 }\n    .${scope} th:${nth} { visibility: hidden }\n\n    /* Inject the background color */\n    .${scope} tr { position: relative }\n    .${scope} td:${nth} div:after {\n      opacity: ${colorOpacity};\n      content: \"\";\n      display: block;\n      height: 100%;\n      width: 100%;\n      position: absolute;\n      left: 0;\n      top: 0;\n      z-index: -1;\n      background-color: var(--row-color);\n    }\n  `);\n\n  return form;\n}\n\n\n\n\n\n\n\ncolumns = [\"stage_num\", \"number\", \"title\", \"stats\", \"stage_date\", \"editor\", \"inactive_for\"]\nreviewTable(filteredSorted,\n  {\n    colorColumn: \"rowColor\",\n    issueNumColumn: \"number\",\n    titleColumn: \"title\",\n    columns: columns,\n    height: 'auto',\n    layout: 'auto',\n    header: {\n        stage_num: \"Stage\",\n        number: \"Number\",\n        title: \"Title\",\n        stats: \"Stats?\",\n        stage_date: \"Stage date\",\n        inactive_for: \"Inactive for\",\n    },\n    format: {\n        stage_num: s =&gt; s === -1 ? \"(No stage)\" : s,\n    }\n  }\n)"
  },
  {
    "objectID": "reviews.html#urgency-of-reviews",
    "href": "reviews.html#urgency-of-reviews",
    "title": "Software Review",
    "section": "Urgency of Reviews",
    "text": "Urgency of Reviews\nLevels of urgency used in the previous table are coloured according to the following scheme:\n\nurgencyDat = transpose(urgency).map(row =&gt; ({\n    ...row,\n    rowColor: row.urgency === 1 ? urgency_colours[0] :\n        row.urgency === 2 ? urgency_colours[1] :\n        row.urgency === 3 ? urgency_colours[2] :\n        row.urgency === 4 ? urgency_colours[3] :\n        row.urgency === 5 ? urgency_colours[4] : \"transparent\",\n}));\n\n\n\n\n\n\n\ncolorTable(urgencyDat, {\n    columns: [\"urgency\", \"importance\"],\n    colorColumn: \"rowColor\",\n})\n\n\n\n\n\n\nLevels of urgency are calculated from the following expected times for each review stage:\n\n\n\nstage\ntime (days)\n\n\n\n\n0/Pre-submission\n7\n\n\n1/Editor Checks\n7\n\n\n2/Seeking Reviewers\n14\n\n\n3/Reviewer(s) Assigned\n21\n\n\n4/Review(s) in Awaiting Changes\n21\n\n\n5/Awaiting Reviewer(s) Response\n21\n\n\n\n\n\n\nLevels of urgency for each review are times taken for current stage as a multiple of those base times, with values rounded down to nearest integer. For example, a submission which has been undergoing 1\\/Editor Checks for 17 days would have an urgency of floor(17/7) = 2. A submission which has been under review (stage 3\\/Reviewer(s) Assigned) for 12 weeks would have an urgency of floor(12 * 7 / 21) = 4. These urgency levels then map on to the colour codes shown above."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "rOpenSci Software Review Dashboard",
    "section": "",
    "text": "This dashboard provides an overview of all current rOpenSci software review issues, and of editor availability and past editorial workloads. The dashboard includes the following components:\n\nThe Editors page which provides information on current editors and activities. This page helps the Editor-in-Charge identify editors for new submissions, and gives each editor an overview of their current and previous editorial portfolios.\nThe Software Review page which provides an overview of all currently open submissions to the software peer-review system. This page is primarily intended to provide an overview of the current state of software peer-review for the Editors-in-Charge, and in particular to identify reviews in need of attention.\nThe Historical Data page which gives insights into the historical developments of the software peer-review program.\n\nSource code for this dashboard is at github.com/ropensci-review-tools/dashboard. Contributions are welcome! Please feel free to open an issue in that repository."
  }
]