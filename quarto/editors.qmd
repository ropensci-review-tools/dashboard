---
title: "rOpenSci Editors"
execute:
  echo: false
format: 
  html:
    fig-width: 8
    fig-height: 8
    code-fold: false
---

```{r load-pkg-ed, echo = FALSE, message = FALSE}
library (dashboard)
library (gt)
library (ggplot2)
library (tidyr)
library (dplyr)
library (ggiraph)
```

```{r open-sans-font, echo = FALSE, message = FALSE}
# ggiraph fonts; issue #23
library (gdtools)
chk <- register_gfont ("Open Sans")
chk <- addGFontHtmlDependency (family = "Open Sans")
```


```{r get-ed-dat, echo = FALSE, message = FALSE}
#| cache: true
aggregation_period <- "quarter"
ed_dat <- editor_status (aggregation_period = aggregation_period, quiet = TRUE)
ed_status <- ed_dat$status
ed_timeline_total <- ed_dat$timeline_total |>
    dplyr::filter (name %in% ed_status$editor)
ed_timeline_new <- ed_dat$timeline_new |>
    dplyr::filter (name %in% ed_status$editor)
```

## Editor Overview {#editor-overview}

The following interactive table summarises the availability of our editorial
team. This information is intended to help identify editors who may be
available to handle new submissions to rOpenSci's software peer-review system.
Values are sorted by the periods of time since editors were last active in peer
review threads (the "last_active" column), sorted in decreasing order so the
first editors are those who have been inactive for the longest time. The choice
of editors should also be made in a way that best distributes the recent
editorial loads depicted in the [*Past Editorial Load*](#past-ed-load) section.


```{r has-free, echo = FALSE, results = "asis"}
some_eds_are_free <- length (ed_status$stats == "FREE") > 0L
msg <- paste0 (
    "Values in the 'last_active' column are ",
    "hyperlinked to the most recent submission issue for each editor. ",
    "The 'Languages' column only describes whether editors are capable of ",
    "handling submissions in any languages other than English currently ",
    "accepted by rOpenSci."
)
msg <- paste0 (
    'The "Stats" selector can be used to select statistical software ',
    '("true") or general ("false") editors (or both). '
)
if (some_eds_are_free) {
    msg <- paste0 (
        msg,
        'Editors with a status of "FREE" are highlighted yellow in the ',
        'table, which by default only shows "FREE" editors. '
    )
}
msg <- paste0 (
    msg,
    'The "Languages" column only describes whether editors are capable ',
    "of handling submissions in any languages other than English ",
    "currently accepted by rOpenSci."
)
cat (msg)
```


```{r clean-editor-status, echo = FALSE}
#| cache: false
eds_to_rm <- dashboard:::eds_to_remove
ed_status <- dplyr::filter (ed_status, !editor %in% eds_to_rm) |>
    dplyr::relocate (other_langs, .before = domain_expertise) |>
    dplyr::rename (
        "Languages" = other_langs,
        "Expertise" = domain_expertise
    ) |>
    tidyr::replace_na (list (inactive_for = "(waiting)"))
```

```{r ojs-def-ed-status}
ed_status$inactive_days [which (is.na (ed_status$inactive_days))] <- .Machine$integer.max
ed_status_filtered <-
    dplyr::select (ed_status, editor, inactive_for, Languages, Expertise, status, stats, number, inactive_days) |>
    dplyr::rename (last_active = inactive_for)
ojs_define (ed_status_in = ed_status_filtered)
```


```{ojs}
ed_status = transpose(ed_status_in)
```

```{ojs}
// Definition of colorTable function, adapted from
// https://observablehq.com/@mootari/colored-table-rows
// This can't be placed in a separate file, because that requires importing
// observable/table, but there is no path here to do that import.
function colorTable(data, {
        colorColumn,
        colorOpacity = 0.5,
        editorColumn,
        lastActiveColumn,
        issueNumColumn,
        columns = undefined,
        format = {}, ...options}) {
  const [row] = data;
  if(!row) return Inputs.table(data, options);
  
  let index = Object.keys(row).indexOf(colorColumn);
  if(index < 0) throw Error("colorColumn not found in data");
  if(format[colorColumn]) throw Error("colorColumn is reserved");
  if(columns && columns.indexOf(colorColumn) < 0) columns.push(colorColumn);
  if(columns) index = columns.indexOf(colorColumn);
  const nth = `nth-child(${index + 2})`;

  // Observable Table doesn't know about rows, so need to convert the
  // "lastActiveColumn" into an array with the issue number and last active
  // string so then pass to the `format` call below to construct <a> href
  // objects:
  const preprocessedData = data.map(row => ({
     ...row,
     [lastActiveColumn]: [row[issueNumColumn],row[lastActiveColumn]]
  }));``

  const form = Inputs.table(preprocessedData, {
    format: {
      ...format,
      [colorColumn]: d => htl.html`<div style="--row-color:${d}">`,
      [editorColumn]: d => htl.html`<a href="https://github.com/${d}">${d}</a>`,
      [lastActiveColumn]: d => htl.html`<a href="https://github.com/ropensci/software-review/issues/${d[0]}">${d[1]}</a>`,
    },
    columns,
    ...options
  });

  const scope = DOM.uid().id;
  form.classList.add(scope);
  
  form.append(htl.html`<style>

    /* Ensure that the sticky header always stays on top */
    .${scope} thead { position: relative; z-index: 2 }

    /* Hide the last column */
    .${scope} th:${nth},
    .${scope} td:${nth} { width: 0; padding: 0 }
    .${scope} th:${nth} { visibility: hidden }

    /* Inject the background color */
    .${scope} tr { position: relative }
    .${scope} td:${nth} div:after {
      opacity: ${colorOpacity};
      content: "";
      display: block;
      height: 100%;
      width: 100%;
      position: absolute;
      left: 0;
      top: 0;
      z-index: -1;
      background-color: var(--row-color);
    }
  `);

  return form;
}
```

```{ojs}
colorData = {
    return ed_status.map(row => ({
        ...row,
        rowColor: row.status === "FREE" ? "yellow" : "transparent",
    }));
}
```

```{ojs}
viewof stats = Inputs.checkbox(
    [true, false],
    { value: [false], 
        label: "Stats:"
    }
)
viewof status = Inputs.checkbox(
    ["FREE", "BUSY", "ON LEAVE"], 
    { value: ["FREE"], 
        label: "Editor Status:"
    }
)
```

```{ojs}
filtered = colorData.filter(function(editor) {
  return status.includes(editor.status) &&
         stats.includes(editor.stats);
})
```
```{ojs}
columns = ["editor", "last_active", "status", "stats", "Languages", "Expertise"]
colorTable(filtered,
  {
    colorColumn: "rowColor",
    editorColumn: "editor",
    lastActiveColumn: "last_active",
    issueNumColumn: "number",
    columns: columns,
    height: 'auto',
  },
  {
    sort: "inactive_days",
    reverse: true
  }
)
```


## Numbers of Editors

rOpenSci relies on our team of volunteer editors. We can only provide review
services if we have sufficient numbers of editors available to handle
submissions. It is therefore important to monitor historical trends in overall
editor availability. This first graph shows total numbers of editors over time,
and corresponding lines for numbers of those engaged during each time period in
ongoing reviews, and numbers who are not handling any submissions during each
period and are therefore free to accept new submissions.

This number of "Free" editors may include those who have yet to edit their
first submissions, in which case these will not appear in any subsequent
graphs. Thus the total number in this first graph may be greater than
identifiable numbers from any subsequent graphs.


```{r ed-availability-prepro, echo = FALSE}
# Use all editors, not just current ones
num_eds_busy <- ed_dat$timeline_total |>
    dplyr::filter (value > 0L) |>
    dplyr::group_by (month) |>
    dplyr::summarise (n = dplyr::n ())

ed_dates <- ed_dat$timeline_total |>
    dplyr::filter (value > 0L) |>
    dplyr::group_by (name) |>
    dplyr::summarise (start = min (month), end = max (month))
ed_dates$end [ed_dates$name %in% ed_status$editor] <- max (ed_dates$end)
ed_dates <- as.matrix (ed_dates [, c ("start", "end")])
dates <- apply (ed_dates, 1, function (i) {
    seq (lubridate::ymd (i [1]), lubridate::ymd (i [2]), by = "quarter") |>
        as.character ()
})
n <- table (unlist (dates))
dates_month <- lubridate::ymd (names (n))
index <- match (dates_month, num_eds_busy$month)

num_eds_total <- num_eds_free <- data.frame (
    month = lubridate::ymd (names (n)),
    n = as.integer (n)
)
index <- match (num_eds_busy$month, num_eds_total$month)
num_eds_free$n [index] <- num_eds_total$n [index] - num_eds_busy$n

# Function to smooth 'busy' and 'free', but not needed in current form.
filter_dat <- function (dat, flen = 5) {
    index <- seq_len (length (dat) - flen + 1) + floor (flen / 2)
    x <- seq_len (flen) - ceiling (flen / 2)
    x <- -abs (x)
    filt <- exp (x)
    filt <- filt / sum (filt)
    dat [index] <- stats::filter (dat, filt) [index]
    return (dat)
}
# num_eds_busy$n <- filter_dat (num_eds_busy$n, flen = 3)
# num_eds_free$n <- filter_dat (num_eds_free$n, flen = 3)

num_eds <- rbind (
    cbind (num_eds_busy, status = "Busy"),
    cbind (num_eds_total, status = "Total"),
    cbind (num_eds_free, status = "Free")
)
```

::: {style="all.initial;"}
```{r timeline-num-eds-plot, echo = FALSE, fig.width = 8, fig.height = 8}
bg_col <- "#DDDDDD55"
ggplot (num_eds, aes (x = month, y = n, colour = status)) +
    geom_line (lwd = 1.0) +
    xlab ("Year") +
    ylab ("Number of editors") +
    theme_minimal () +
    theme (
        plot.background = element_rect (fill = bg_col),
        panel.grid.major = element_line (colour = "#CCCCCC"),
        panel.grid.minor = element_blank (),
        legend.position = "inside",
        legend.position.inside = c (0.1, 0.8),
        axis.text.x = element_text (size = 12),
        axis.text.y = element_text (size = 10),
        axis.title = element_text (size = 14)
    )
```
:::

<br><br>

## Editorial Load {#past-ed-load}

The following sections summarise the recent workload of our editorial team.
This is intended to be the primary aid used in selecting editors for new
submission. We aim to distribute our workload as evenly as possible across the
editorial team. Editors for new submissions should accordingly be chosen from
those who have had relatively low recent workloads. All of the following data
and graphs exclude any editors who are currently on leave.

```{r ed-summary, echo = FALSE}
# Reduce data to prior year only:
start_date <- lubridate::ymd (Sys.Date ()) - lubridate::years (1L)
start_quarter <- lubridate::quarter (start_date, type = "date_first")
timeline_total <- dplyr::filter (ed_timeline_total, month >= start_quarter) |>
    dplyr::rename (reviews_tot = value) |>
    dplyr::filter (reviews_tot > 0)
timeline_new <- dplyr::filter (ed_timeline_new, month >= start_quarter) |>
    dplyr::rename (reviews_new = value) |>
    dplyr::filter (reviews_new > 0)
```


### Individual Editor Load: New Submissions {#ed-load-new}

This first graph shows the number of *new* submissions per quarter taken on by
each editor. We aim to allocate no more than one new submission to each editor
per quarter, or a maximum of four per year. Each block in this graph represents
a quarter-year, so values should not exceed one. Editors for incoming reviews
should preferably be chosen from those who have not handled any submissions in
the present or preceding quarters.

```{r ed-load-params, echo = FALSE}
min_rev_total <- 0L # Don't show any data for reviews <= this value
span_years <- 2L # Show this many years of data
```
```{r timelines-prepro, echo = FALSE}
start_date <- lubridate::ymd (Sys.Date ()) - lubridate::years (span_years)
start_quarter <- lubridate::quarter (start_date, type = "date_first")
timeline_total <- dplyr::filter (ed_timeline_total, month >= start_quarter) |>
    dplyr::rename (reviews = value) |>
    dplyr::filter (reviews > min_rev_total)

ncols <- diff (range (timeline_total$reviews)) + 1L
cols <- rev (heat.colors (ncols))
timeline_total$col <- cols [timeline_total$reviews - min_rev_total]
# Remove any editors who are on leave:
eds_on_leave <- ed_status$editor [which (ed_status$status == "ON LEAVE")]
timeline_total <- dplyr::filter (timeline_total, !(name %in% eds_on_leave))
max_reviews <- max (timeline_total$reviews)

min_rev_new <- 0L
timeline_new <- dplyr::filter (ed_timeline_new, month >= start_quarter) |>
    dplyr::rename (reviews = value) |>
    dplyr::filter (reviews > min_rev_new)
ncols <- diff (range (timeline_new$reviews)) + 1L
cols <- rev (heat.colors (ncols))
timeline_new$col <- cols [timeline_new$reviews - min_rev_new]
timeline_new <- dplyr::filter (timeline_new, !(name %in% eds_on_leave))
```

```{r set-fig-ht-all, echo = FALSE}
# Scale height of fig to number of editors. The `h0` value of 1 corresponds to
# 8 editors fitting within a square graphic.
opts <- knitr::opts_chunk$get ()
neds <- length (unique (timeline_new$name))
h0 <- 1
ht <- ceiling (h0 * neds)
knitr::opts_chunk$set (fig.height = ht)
```


::: {style="all.initial;"}
```{r timeline_new-plot, echo = FALSE, fig.width = 8}
break_interval <- 2
ymax <- max (timeline_new$reviews)
breaks <- seq (0, ceiling (ymax / break_interval)) * break_interval

qtrs <- lubridate::quarter (timeline_new$month, with_year = TRUE)
qtrs <- gsub ("\\.", ".Q", qtrs)
timeline_new$tt <- paste0 (
    timeline_new$name,
    " ",
    qtrs,
    ": ",
    timeline_new$reviews,
    " new ",
    ifelse (timeline_new$reviews == 1, "submission", "submissions")
)

ggplot (timeline_new, aes (x = month, y = reviews, fill = col)) +
    ggiraph::geom_col_interactive (
        width = 80,
        just = 0,
        aes (tooltip = tt, data_id = tt, hover_nearest = FALSE)
    ) +
    scale_y_continuous (position = "left", breaks = breaks) +
    scale_fill_identity () +
    facet_wrap (
        ~name,
        ncol = 1,
        strip.position = "right"
    ) +
    xlab ("Annual Quarter") +
    ylab ("Numbers of new reviews / quarter") +
    theme_minimal (base_family = "sans") +
    theme (
        plot.background = element_rect (fill = bg_col),
        panel.grid.major = element_line (colour = "#CCCCCC"),
        panel.grid.minor = element_blank (),
        legend.position = "none",
        axis.text.x = element_text (size = 12, family = "sans"),
        axis.text.y = element_text (size = 10, family = "sans"),
        axis.title = element_text (size = 14, family = "sans"),
        strip.text = element_text (size = 14, family = "sans"),
        strip.text.y = element_text (angle = 0, hjust = 0, vjust = 0, family = "sans"),
        strip.clip = "on",
        strip.background = element_blank ()
    ) -> g
ggiraph::girafe (ggobj = g, fonts = list (sans = "Open Sans"))
```
:::

### Individual Editor Load: Concurrent Reviews {#ed-load-concurrent}


The following graph shows numbers of concurrent reviews handled by editors over
the preceding `r span_years` years. We aim to distribute workloads across
editors as evenly as possible, and this graph should be used in addition to the
above graph to aid that task. Note that we have no specific upper limits on
numbers of concurrent reviews, and reviews may extend over long time periods
with very little editorial intervention. Nevertheless, low numbers of
concurrent reviews may be interpreted to reflect relatively low editorial
workload.

```{r set-fig-ht-new, echo = FALSE}
neds <- length (unique (timeline_total$name))
ht <- ceiling (h0 * neds) # h0 defined in previous chunk
knitr::opts_chunk$set (fig.height = ht)
```

::: {style="all.initial;"}
```{r timeline_total-plot, echo = FALSE, fig.width = 8}
break_interval <- 4
ymax <- max (timeline_total$reviews)
breaks <- seq (0, ceiling (ymax / break_interval)) * break_interval

qtrs <- lubridate::quarter (timeline_total$month, with_year = TRUE)
qtrs <- gsub ("\\.", ".Q", qtrs)
timeline_total$tt <- paste0 (
    timeline_total$name,
    " ",
    qtrs,
    ": ",
    timeline_total$reviews,
    ifelse (timeline_total$reviews == 1, "review", "reviews")
)

ggplot (timeline_total, aes (x = month, y = reviews, fill = col)) +
    ggiraph::geom_col_interactive (
        width = 80,
        just = 0,
        aes (tooltip = tt, data_id = tt, hover_nearest = FALSE)
    ) +
    scale_y_continuous (position = "left", breaks = breaks) +
    scale_fill_identity () +
    facet_wrap (
        ~name,
        ncol = 1,
        strip.position = "right"
    ) +
    xlab ("Annual Quarter") +
    ylab ("Numbers of concurrent reviews / quarter") +
    theme_minimal (base_family = "sans") +
    theme (
        plot.background = element_rect (fill = bg_col),
        panel.grid.major = element_line (colour = "#CCCCCC"),
        panel.grid.minor = element_blank (),
        legend.position = "none",
        axis.text.x = element_text (size = 12, family = "sans"),
        axis.text.y = element_text (size = 10, family = "sans"),
        axis.title = element_text (size = 14, family = "sans"),
        strip.text = element_text (size = 14, family = "sans"),
        strip.text.y = element_text (angle = 0, hjust = 0, vjust = 0, family = "sans"),
        strip.clip = "on",
        strip.background = element_blank ()
    ) -> g
ggiraph::girafe (ggobj = g, fonts = list (sans = "Open Sans"))
```
:::

<br><br>


```{r reset-fig-ht, echo = FALSE}
knitr::opts_chunk$set (fig.height = opts$fig.height)
```
