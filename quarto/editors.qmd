---
title: "rOpenSci Editors"
execute:
  echo: false
format: 
  html:
    fig-width: 8
    fig-height: 8
    code-fold: false
---

```{r load-pkg-ed, echo = FALSE, message = FALSE}
library (dashboard)
library (ggplot2)
library (tidyr)
library (dplyr)
library (ggiraph)
```

```{r open-sans-font, echo = FALSE, message = FALSE}
# ggiraph fonts; issue #23
library (gdtools)
chk <- register_gfont ("Open Sans")
chk <- addGFontHtmlDependency (family = "Open Sans")
```


```{r get-ed-dat, echo = FALSE, message = FALSE}
#| cache: true
aggregation_period <- "quarter"
ed_dat <- editor_status (aggregation_period = aggregation_period, quiet = TRUE)
ed_status <- ed_dat$status
ed_timeline_total <- ed_dat$timeline_total |>
    dplyr::filter (name %in% ed_status$editor)
ed_timeline_new <- ed_dat$timeline_new |>
    dplyr::filter (name %in% ed_status$editor)
```

## Editor Overview {#editor-overview}

The following interactive table summarises the availability of our editorial
team. This information is intended to help identify editors who may be
available to handle new submissions to rOpenSci's software peer-review system.
Values are sorted by the periods of time since editors were last active in peer
review threads (the "last_active" column), sorted in decreasing order so the
first editors are those who have been inactive for the longest time. The choice
of editors should also be made in a way that best distributes the recent
editorial loads depicted in the [*Past Editorial Load*](#past-ed-load) section.


```{r has-free, echo = FALSE, results = "asis"}
some_eds_are_free <- length (ed_status$stats == "FREE") > 0L
msg <- paste0 (
    "Values in the 'last_active' column are ",
    "hyperlinked to the most recent submission issue for each editor. ",
    "The 'Languages' column only describes whether editors are capable of ",
    "handling submissions in any languages other than English currently ",
    "accepted by rOpenSci."
)
msg <- paste0 (
    'The "Stats" selector can be used to select statistical software ',
    '("true") or general ("false") editors (or both). '
)
if (some_eds_are_free) {
    msg <- paste0 (
        msg,
        'Editors with a status of "FREE" are highlighted yellow in the ',
        'table, which by default only shows "FREE" editors. '
    )
}
msg <- paste0 (
    msg,
    'The "Languages" column only describes whether editors are capable ',
    "of handling submissions in any languages other than English ",
    "currently accepted by rOpenSci."
)
cat (msg)
```


```{r clean-editor-status, echo = FALSE}
#| cache: false
eds_to_rm <- dashboard:::eds_to_remove
ed_status <- dplyr::filter (ed_status, !editor %in% eds_to_rm) |>
    dplyr::relocate (other_langs, .before = domain_expertise) |>
    dplyr::rename (
        "Languages" = other_langs,
        "Expertise" = domain_expertise
    ) |>
    tidyr::replace_na (list (inactive_for = "(waiting)"))
```

```{r ojs-def-ed-status}
#| cache: false
ed_status$inactive_days [which (is.na (ed_status$inactive_days))] <- .Machine$integer.max
ed_status_filtered <-
    dplyr::select (ed_status, editor, inactive_for, Languages, Expertise, status, stats, number, inactive_days) |>
    dplyr::rename (last_active = inactive_for)
ojs_define (ed_status_in = ed_status_filtered)
```

```{ojs}
// This adds a 'rowColor' variable to the editor data
editorData = {
    return transpose(ed_status_in).map(row => ({
        ...row,
        rowColor: row.status === "FREE" ? "yellow" : "transparent",
    }));
}
```

```{ojs}
// These are the two checkboxes which appear before the table:
viewof stats = Inputs.checkbox(
    [true, false],
    { value: [false], 
        label: "Stats:"
    }
)
viewof status = Inputs.checkbox(
    ["FREE", "BUSY", "ON LEAVE"], 
    { value: ["FREE"], 
        label: "Editor Status:"
    }
)
```

```{ojs}
// This filters the editor data based on the checkboxes, and then sorts here,
// because Observable tables can only be sorted by visible columns.

filtered = editorData.filter(function(editor) {
  return status.includes(editor.status) &&
         stats.includes(editor.stats);
})

sortColumn = "inactive_days"

// This sorts in reverse order:
filteredSorted = filtered.sort((a, b) => {
  if (a[sortColumn] < b[sortColumn]) {
    return 1;
  }
  if (a[sortColumn] > b[sortColumn]) {
    return -1;
  }
  return 0;
});
```

{{< include _colorTable_fn.qmd >}}

```{ojs}
// And this uses the 'colorTable' function defined in the above file to
// generate an Observable Inputs.table with coloured rows.
columns = ["editor", "last_active", "status", "stats", "Languages", "Expertise"]
colorTable(filteredSorted,
  {
    colorColumn: "rowColor",
    editorColumn: "editor",
    lastActiveColumn: "last_active",
    issueNumColumn: "number",
    columns: columns,
    height: 'auto',
  }
)
```


<br><br>

## Editorial Load {#past-ed-load}

The following sections summarise the recent workload of our editorial team. We
aim to distribute our workload as evenly as possible across the editorial team.
Editors for new submissions should accordingly be chosen from those who have
had relatively low recent workloads. All of the following data and graphs
exclude any editors who are currently on leave.


### Individual Editor Load: New Submissions {#ed-load-new}

This first graph shows the number of *new* submissions per quarter taken on by
each editor. We aim to allocate no more than one new submission to each editor
per quarter, or a maximum of four per year. Each block in this graph represents
a quarter-year, so values should not exceed one. Editors for incoming reviews
should preferably be chosen from those who have not handled any submissions in
the present or preceding quarters.

```{r ed-load-params, echo = FALSE}
min_rev_total <- 0L # Don't show any data for reviews <= this value
span_years <- 2L # Show this many years of data
```
```{r timelines-prepro, echo = FALSE}
start_date <- lubridate::ymd (Sys.Date ()) - lubridate::years (span_years)
start_quarter <- lubridate::quarter (start_date, type = "date_first")
timeline_total <- dplyr::filter (ed_timeline_total, month >= start_quarter) |>
    dplyr::rename (reviews = value) |>
    dplyr::filter (reviews > min_rev_total)

ncols <- diff (range (timeline_total$reviews)) + 1L
cols <- rev (heat.colors (ncols))
timeline_total$col <- cols [timeline_total$reviews - min_rev_total]
# Remove any editors who are on leave:
eds_on_leave <- ed_status$editor [which (ed_status$status == "ON LEAVE")]
timeline_total <- dplyr::filter (timeline_total, !(name %in% eds_on_leave))
max_reviews <- max (timeline_total$reviews)

min_rev_new <- 0L
timeline_new <- dplyr::filter (ed_timeline_new, month >= start_quarter) |>
    dplyr::rename (reviews = value) |>
    dplyr::filter (reviews > min_rev_new)
ncols <- diff (range (timeline_new$reviews)) + 1L
cols <- rev (heat.colors (ncols))
timeline_new$col <- cols [timeline_new$reviews - min_rev_new]
timeline_new <- dplyr::filter (timeline_new, !(name %in% eds_on_leave))
```

```{r set-fig-ht-all, echo = FALSE}
# Scale height of fig to number of editors. The `h0` value of 1 corresponds to
# 8 editors fitting within a square graphic.
opts <- knitr::opts_chunk$get ()
neds <- length (unique (timeline_new$name))
h0 <- 1
ht <- ceiling (h0 * neds)
knitr::opts_chunk$set (fig.height = ht)
```


::: {style="all.initial;"}
```{r timeline_new-plot, echo = FALSE, fig.width = 8}
break_interval <- 2
bg_col <- "#DDDDDD55"

ymax <- max (timeline_new$reviews)
breaks <- seq (0, ceiling (ymax / break_interval)) * break_interval

qtrs <- lubridate::quarter (timeline_new$month, with_year = TRUE)
qtrs <- gsub ("\\.", ".Q", qtrs)
timeline_new$tt <- paste0 (
    timeline_new$name,
    " ",
    qtrs,
    ": ",
    timeline_new$reviews,
    " new ",
    ifelse (timeline_new$reviews == 1, "submission", "submissions")
)

ggplot (timeline_new, aes (x = month, y = reviews, fill = col)) +
    ggiraph::geom_col_interactive (
        width = 80,
        just = 0,
        aes (tooltip = tt, data_id = tt, hover_nearest = FALSE)
    ) +
    scale_y_continuous (position = "left", breaks = breaks) +
    scale_fill_identity () +
    facet_wrap (
        ~name,
        ncol = 1,
        strip.position = "right"
    ) +
    xlab ("Annual Quarter") +
    ylab ("Numbers of new reviews / quarter") +
    theme_minimal (base_family = "sans") +
    theme (
        plot.background = element_rect (fill = bg_col),
        panel.grid.major = element_line (colour = "#CCCCCC"),
        panel.grid.minor = element_blank (),
        legend.position = "none",
        axis.text.x = element_text (size = 12, family = "sans"),
        axis.text.y = element_text (size = 10, family = "sans"),
        axis.title = element_text (size = 14, family = "sans"),
        strip.text = element_text (size = 14, family = "sans"),
        strip.text.y = element_text (angle = 0, hjust = 0, vjust = 0, family = "sans"),
        strip.clip = "on",
        strip.background = element_blank ()
    ) -> g
ggiraph::girafe (ggobj = g, fonts = list (sans = "Open Sans"))
```
:::

### Individual Editor Load: Concurrent Reviews {#ed-load-concurrent}


The following graph shows numbers of concurrent reviews handled by editors over
the preceding `r span_years` years. We aim to distribute workloads across
editors as evenly as possible, and this graph should be used in addition to the
above graph to aid that task. Note that we have no specific upper limits on
numbers of concurrent reviews, and reviews may extend over long time periods
with very little editorial intervention. Nevertheless, low numbers of
concurrent reviews may be interpreted to reflect relatively low editorial
workload.

```{r set-fig-ht-new, echo = FALSE}
neds <- length (unique (timeline_total$name))
ht <- ceiling (h0 * neds) # h0 defined in previous chunk
knitr::opts_chunk$set (fig.height = ht)
```

::: {style="all.initial;"}
```{r timeline_total-plot, echo = FALSE, fig.width = 8}
break_interval <- 4
ymax <- max (timeline_total$reviews)
breaks <- seq (0, ceiling (ymax / break_interval)) * break_interval

qtrs <- lubridate::quarter (timeline_total$month, with_year = TRUE)
qtrs <- gsub ("\\.", ".Q", qtrs)
timeline_total$tt <- paste0 (
    timeline_total$name,
    " ",
    qtrs,
    ": ",
    timeline_total$reviews,
    ifelse (timeline_total$reviews == 1, "review", "reviews")
)

ggplot (timeline_total, aes (x = month, y = reviews, fill = col)) +
    ggiraph::geom_col_interactive (
        width = 80,
        just = 0,
        aes (tooltip = tt, data_id = tt, hover_nearest = FALSE)
    ) +
    scale_y_continuous (position = "left", breaks = breaks) +
    scale_fill_identity () +
    facet_wrap (
        ~name,
        ncol = 1,
        strip.position = "right"
    ) +
    xlab ("Annual Quarter") +
    ylab ("Numbers of concurrent reviews / quarter") +
    theme_minimal (base_family = "sans") +
    theme (
        plot.background = element_rect (fill = bg_col),
        panel.grid.major = element_line (colour = "#CCCCCC"),
        panel.grid.minor = element_blank (),
        legend.position = "none",
        axis.text.x = element_text (size = 12, family = "sans"),
        axis.text.y = element_text (size = 10, family = "sans"),
        axis.title = element_text (size = 14, family = "sans"),
        strip.text = element_text (size = 14, family = "sans"),
        strip.text.y = element_text (angle = 0, hjust = 0, vjust = 0, family = "sans"),
        strip.clip = "on",
        strip.background = element_blank ()
    ) -> g
ggiraph::girafe (ggobj = g, fonts = list (sans = "Open Sans"))
```
:::

<br><br>


```{r reset-fig-ht, echo = FALSE}
knitr::opts_chunk$set (fig.height = opts$fig.height)
```

## Numbers of Editors

rOpenSci relies on our team of volunteer editors. We can only provide review
services if we have sufficient numbers of editors available to handle
submissions. It is therefore important to monitor historical trends in overall
editor availability. This first graph shows total numbers of editors over time,
and corresponding lines for numbers of those engaged during each time period in
ongoing reviews, and numbers who are not handling any submissions during each
period and are therefore free to accept new submissions.

This number of "Free" editors may include those who have yet to edit their
first submissions, in which case these will not appear in any subsequent
graphs. Thus the total number in this first graph may be greater than
identifiable numbers from any subsequent graphs.


```{r ed-availability-prepro, echo = FALSE}
# Use all editors, not just current ones
num_eds_busy <- ed_dat$timeline_total |>
    dplyr::filter (value > 0L) |>
    dplyr::group_by (month) |>
    dplyr::summarise (n = dplyr::n ())

ed_dates <- ed_dat$timeline_total |>
    dplyr::filter (value > 0L) |>
    dplyr::group_by (name) |>
    dplyr::summarise (start = min (month), end = max (month))
ed_dates$end [ed_dates$name %in% ed_status$editor] <- max (ed_dates$end)
ed_dates <- as.matrix (ed_dates [, c ("start", "end")])
dates <- apply (ed_dates, 1, function (i) {
    seq (lubridate::ymd (i [1]), lubridate::ymd (i [2]), by = "quarter") |>
        as.character ()
})
n <- table (unlist (dates))
dates_month <- lubridate::ymd (names (n))
index <- match (dates_month, num_eds_busy$month)

num_eds_total <- num_eds_free <- data.frame (
    month = lubridate::ymd (names (n)),
    n = as.integer (n)
)
index <- match (num_eds_busy$month, num_eds_total$month)
num_eds_free$n [index] <- num_eds_total$n [index] - num_eds_busy$n

# Function to smooth 'busy' and 'free', but not needed in current form.
filter_dat <- function (dat, flen = 5) {
    index <- seq_len (length (dat) - flen + 1) + floor (flen / 2)
    x <- seq_len (flen) - ceiling (flen / 2)
    x <- -abs (x)
    filt <- exp (x)
    filt <- filt / sum (filt)
    dat [index] <- stats::filter (dat, filt) [index]
    return (dat)
}
# num_eds_busy$n <- filter_dat (num_eds_busy$n, flen = 3)
# num_eds_free$n <- filter_dat (num_eds_free$n, flen = 3)

num_eds <- rbind (
    cbind (num_eds_busy, status = "Busy"),
    cbind (num_eds_total, status = "Total"),
    cbind (num_eds_free, status = "Free")
)
```

::: {style="all.initial;"}
```{r timeline-num-eds-plot, echo = FALSE, fig.width = 8, fig.height = 8}
ggplot (num_eds, aes (x = month, y = n, colour = status)) +
    geom_line (lwd = 1.0) +
    xlab ("Year") +
    ylab ("Number of editors") +
    theme_minimal () +
    theme (
        plot.background = element_rect (fill = bg_col),
        panel.grid.major = element_line (colour = "#CCCCCC"),
        panel.grid.minor = element_blank (),
        legend.position = "inside",
        legend.position.inside = c (0.1, 0.8),
        axis.text.x = element_text (size = 12),
        axis.text.y = element_text (size = 10),
        axis.title = element_text (size = 14)
    )
```
:::
